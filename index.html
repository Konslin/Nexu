<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tetris</title>
<style>
    :root {
        --bg: #111;
        --panel: #0f1720;
        --accent: #00d1b2;
        --muted: #94a3b8;
    }
    * { box-sizing: border-box; }
    html,body { height:100%; margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: linear-gradient(180deg,#071025 0%, #081225 100%); color:#e6eef6; }
    .shell { min-height:100%; display:flex; align-items:center; justify-content:center; padding:16px; }
    .container { display:flex; gap:16px; align-items:flex-start; width:100%; max-width:1100px; }

    /* board + responsive canvas */
    .board {
        background: linear-gradient(180deg,#071428 0%, #081526 100%);
        padding:12px; border-radius:8px; box-shadow:0 6px 30px rgba(2,6,23,0.6);
        flex: 1 1 auto;
        display:flex;
        justify-content:center;
        align-items:center;
    }
    canvas { background: #02101a; display:block; image-rendering: pixelated; border-radius:6px; }

    /* Make canvas scale responsively while keeping internal resolution */
    /* Aspect ratio 10:20 (width:height = 1:2) */
    .board canvas {
        width: min(72vw, 360px); /* adapt to viewport on mobile, cap on desktop */
        height: auto;
        aspect-ratio: 10 / 20;
    }

    .sidebar {
        width:230px; padding:12px; background:var(--panel); border-radius:8px; box-shadow:0 6px 24px rgba(0,0,0,0.4);
        flex: 0 0 auto;
    }
    .meta { display:grid; gap:8px; margin-bottom:12px; }
    .meta .row { display:flex; justify-content:space-between; color:var(--muted); font-size:14px; }
    .controls { display:flex; gap:8px; margin-bottom:8px; }
    button { flex:1; padding:8px 10px; border-radius:6px; border:0; background:var(--accent); color:#042226; font-weight:600; cursor:pointer; }
    button.secondary { background:#1f2937; color:#cfeff0; font-weight:600; }
    small { color:var(--muted); display:block; margin-top:6px; font-size:12px; }
    .nextwrap { display:flex; gap:8px; align-items:center; }
    .hint { margin-top:8px; color:var(--muted); font-size:13px; line-height:1.3; }
    footer { margin-top:10px; color:var(--muted); font-size:12px; text-align:center; }
    .credits { font-size:12px; color:var(--muted); margin-top:8px; text-align:center; }

    /* Next preview canvas responsive */
    #next { width:100%; max-width:96px; height:auto; aspect-ratio: 1/1; }

    /* Mobile controls: only show on touch/coarse-pointer devices */
    .mobile-controls {
        position: fixed;
        left: 50%;
        transform: translateX(-50%);
        bottom: 18px;
        display: none;
        gap: 12px;
        align-items: center;
        z-index: 60;
    }
    .mobile-controls .group { display:flex; gap:8px; }
    .mc-btn {
        width:56px; height:56px; border-radius:50%; background:rgba(2,16,20,0.9); border:1px solid rgba(255,255,255,0.04); color:#cfeff0; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:18px; box-shadow:0 6px 20px rgba(2,6,23,0.6);
        touch-action: manipulation;
    }
    .mc-btn:active { transform: scale(0.96); }

    /* Show mobile controls on touch devices (coarse pointer) */
    @media (pointer: coarse) {
        .mobile-controls { display:flex; }
        /* on small screens hide keyboard hint */
        .hint { display:none; }
        /* sidebar smaller on narrow screens */
        .sidebar { width:180px; padding:10px; }
    }

    /* Layout tweaks for very small screens */
    @media (max-width:720px) {
        .container { flex-direction: column; align-items:center; gap:12px; }
        .sidebar { width:90%; max-width:360px; }
        .board { order: 0; width:100%; }
    }
</style>
</head>
<body>
<div class="shell">
    <div class="container">
        <div class="board">
            <canvas id="board" width="300" height="600"></canvas>
        </div>
        <div class="sidebar">
            <div class="meta">
                <div class="row"><span>Puntos</span><strong id="score">0</strong></div>
                <div class="row"><span>Lineas</span><strong id="lines">0</strong></div>
                <div class="row"><span>Nivel</span><strong id="level">1</strong></div>
            </div>

            <div class="nextwrap">
                <div style="flex:1;">
                    <div style="color:var(--muted); font-size:13px; margin-bottom:6px;">Siguiente</div>
                    <canvas id="next" width="120" height="120" style="background:#071422; border-radius:6px;"></canvas>
                </div>
            </div>

            <div class="controls" style="margin-top:14px;">
                <button id="start">Iniciar</button>
                <button id="pause" class="secondary">Pausa</button>
            </div>

            <div class="hint">
                Controles: ← → para mover, ↑ para rotar, ↓ para bajar, Barra espaciadora para soltar, P pausar.
            </div>

            <div class="credits">Hecho en HTML/JS • Pequeño Tetris</div>
        </div>
    </div>
</div>

<!-- Mobile-only on-screen controls (appear on touch devices / coarse pointers) -->
<div class="mobile-controls" id="mobileControls" aria-hidden="true">
    <div class="group">
        <button class="mc-btn" data-action="left">◀</button>
        <button class="mc-btn" data-action="right">▶</button>
    </div>
    <div class="group">
        <button class="mc-btn" data-action="rotate">⤴︎</button>
        <button class="mc-btn" data-action="down">▼</button>
        <button class="mc-btn" data-action="drop">⤓</button>
    </div>
</div>

<script>
/* Configuración */
const COLS = 10, ROWS = 20;
const BLOCK = 30; // tamaño en px (resolución interna)
const LINES_PER_LEVEL = 10;

/* Canvas */
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
canvas.width = COLS * BLOCK;
canvas.height = ROWS * BLOCK;

const nextCanvas = document.getElementById('next');
const nctx = nextCanvas.getContext('2d');
nextCanvas.width = 4 * BLOCK;
nextCanvas.height = 4 * BLOCK;

/* UI */
const scoreEl = document.getElementById('score');
const linesEl = document.getElementById('lines');
const levelEl = document.getElementById('level');
const startBtn = document.getElementById('start');
const pauseBtn = document.getElementById('pause');

/* Piezas y colores */
const PIECES = {
    I: {
        rotations: [
            [[0,1],[1,1],[2,1],[3,1]],
            [[2,0],[2,1],[2,2],[2,3]]
        ],
        color: '#00e5ff'
    },
    J: {
        rotations: [
            [[0,0],[0,1],[1,1],[2,1]],
            [[1,0],[2,0],[1,1],[1,2]],
            [[0,1],[1,1],[2,1],[2,2]],
            [[1,0],[1,1],[0,2],[1,2]]
        ],
        color: '#3346ff'
    },
    L: {
        rotations: [
            [[2,0],[0,1],[1,1],[2,1]],
            [[1,0],[1,1],[1,2],[2,2]],
            [[0,1],[1,1],[2,1],[0,2]],
            [[0,0],[1,0],[1,1],[1,2]]
        ],
        color: '#ff9800'
    },
    O: {
        rotations: [
            [[1,0],[2,0],[1,1],[2,1]]
        ],
        color: '#ffd400'
    },
    S: {
        rotations: [
            [[1,0],[2,0],[0,1],[1,1]],
            [[1,0],[1,1],[2,1],[2,2]]
        ],
        color: '#00c853'
    },
    T: {
        rotations: [
            [[1,0],[0,1],[1,1],[2,1]],
            [[1,0],[1,1],[2,1],[1,2]],
            [[0,1],[1,1],[2,1],[1,2]],
            [[1,0],[0,1],[1,1],[1,2]]
        ],
        color: '#9b59b6'
    },
    Z: {
        rotations: [
            [[0,0],[1,0],[1,1],[2,1]],
            [[2,0],[1,1],[2,1],[1,2]]
        ],
        color: '#ff3b30'
    }
};
const PIECE_KEYS = Object.keys(PIECES);

/* Estado del juego */
let grid = createGrid(COLS, ROWS);
let current = null;
let next = randomPiece();
let score = 0, lines = 0, level = 1;
let dropCounter = 0, dropInterval = 1000;
let lastTime = 0;
let running = false;
let paused = false;

/* Helpers */
function createGrid(cols, rows) {
    const g = [];
    for (let y = 0; y < rows; y++) {
        g[y] = new Array(cols).fill(null);
    }
    return g;
}

function randomPiece() {
    const key = PIECE_KEYS[Math.floor(Math.random() * PIECE_KEYS.length)];
    const meta = PIECES[key];
    return {
        name: key,
        rotations: meta.rotations,
        color: meta.color,
        rot: 0,
        x: Math.floor((COLS - 4) / 2), // starting offset
        y: -1
    };
}

function getCells(piece) {
    return piece.rotations[piece.rot].map(([x,y]) => ({ x: x + piece.x, y: y + piece.y }));
}

function collide(grid, piece) {
    for (const c of getCells(piece)) {
        if (c.y >= ROWS) return true;
        if (c.x < 0 || c.x >= COLS) return true;
        if (c.y >= 0 && grid[c.y][c.x]) return true;
    }
    return false;
}

function rotate(piece, dir = 1) {
    const oldRot = piece.rot;
    piece.rot = (piece.rot + dir + piece.rotations.length) % piece.rotations.length;
    // wallkick simple: try shifts
    const kicks = [0, -1, 1, -2, 2];
    for (const k of kicks) {
        piece.x += k;
        if (!collide(grid, piece)) return true;
        piece.x -= k;
    }
    piece.rot = oldRot;
    return false;
}

function merge(grid, piece) {
    for (const c of getCells(piece)) {
        if (c.y >= 0) grid[c.y][c.x] = piece.color;
    }
}

function clearLines() {
    let dropped = 0;
    for (let y = ROWS - 1; y >= 0;) {
        if (grid[y].every(cell => cell !== null)) {
            grid.splice(y, 1);
            grid.unshift(new Array(COLS).fill(null));
            dropped++;
        } else {
            y--;
        }
    }
    if (dropped > 0) {
        lines += dropped;
        score += computeScore(dropped);
        level = Math.floor(lines / LINES_PER_LEVEL) + 1;
        dropInterval = Math.max(100, 1000 - (level - 1) * 80);
        updateUI();
    }
}

function computeScore(rows) {
    if (rows === 1) return 40 * level;
    if (rows === 2) return 100 * level;
    if (rows === 3) return 300 * level;
    if (rows === 4) return 1200 * level;
    return 0;
}

/* Game actions */
function spawn() {
    current = next;
    current.x = Math.floor((COLS - 4) / 2);
    current.y = -1;
    next = randomPiece();
    if (collide(grid, current)) {
        running = false;
        alert('Game Over\nPuntos: ' + score);
        reset();
    }
}

function hardDrop() {
    while (!collide(grid, { ...current, y: current.y + 1 })) {
        current.y++;
    }
    lockPiece();
}

function lockPiece() {
    merge(grid, current);
    clearLines();
    spawn();
}

function move(dx) {
    current.x += dx;
    if (collide(grid, current)) current.x -= dx;
}

/* Rendering */
function drawCell(ctx, x, y, color) {
    const pad = 1;
    ctx.fillStyle = color;
    ctx.fillRect(x * BLOCK + pad, y * BLOCK + pad, BLOCK - pad * 2, BLOCK - pad * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(x * BLOCK + pad, y * BLOCK + pad, BLOCK - pad * 2, 6);
}

function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#02101a';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    for (let y=0;y<ROWS;y++){
        for (let x=0;x<COLS;x++){
            const c = grid[y][x];
            if (c) drawCell(ctx, x, y, c);
        }
    }
    if (current) {
        for (const c of getCells(current)) {
            if (c.y >= 0) drawCell(ctx, c.x, c.y, current.color);
        }
    }

    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 1;
    for (let x=0;x<=COLS;x++){
        ctx.beginPath(); ctx.moveTo(x*BLOCK,0); ctx.lineTo(x*BLOCK,ROWS*BLOCK); ctx.stroke();
    }
    for (let y=0;y<=ROWS;y++){
        ctx.beginPath(); ctx.moveTo(0,y*BLOCK); ctx.lineTo(COLS*BLOCK,y*BLOCK); ctx.stroke();
    }
}

function drawNext() {
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    nctx.fillStyle = '#071422';
    nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
    const px = 0, py = 0;
    const p = next;
    const cells = p.rotations[p.rot];
    for (const [x,y] of cells) {
        nctx.fillStyle = p.color;
        nctx.fillRect((x+px) * BLOCK + 1, (y+py) * BLOCK + 1, BLOCK - 2, BLOCK - 2);
        nctx.fillStyle = 'rgba(255,255,255,0.06)';
        nctx.fillRect((x+px) * BLOCK + 1, (y+py) * BLOCK + 1, BLOCK - 2, 6);
    }
}

/* Loop */
function update(time = 0) {
    if (!running || paused) { lastTime = time; requestAnimationFrame(update); return; }
    const delta = time - lastTime;
    lastTime = time;
    dropCounter += delta;
    if (dropCounter > dropInterval) {
        current.y++;
        if (collide(grid, current)) {
            current.y--;
            lockPiece();
        }
        dropCounter = 0;
    }
    draw();
    drawNext();
    requestAnimationFrame(update);
}

/* Input keyboard */
document.addEventListener('keydown', (e) => {
    if (!running) return;
    if (e.key === 'ArrowLeft') { move(-1); draw(); }
    else if (e.key === 'ArrowRight') { move(1); draw(); }
    else if (e.key === 'ArrowDown') { current.y++; if (collide(grid,current)) { current.y--; lockPiece(); } draw(); }
    else if (e.key === 'ArrowUp') { rotate(current, 1); draw(); }
    else if (e.code === 'Space') { e.preventDefault(); hardDrop(); draw(); }
    else if (e.key.toLowerCase() === 'p') { togglePause(); }
});

startBtn.addEventListener('click', () => {
    reset();
    start();
});
pauseBtn.addEventListener('click', togglePause);

function reset() {
    grid = createGrid(COLS, ROWS);
    current = null;
    next = randomPiece();
    score = 0; lines = 0; level = 1;
    dropInterval = 1000;
    updateUI();
    draw();
    drawNext();
}

function updateUI() {
    scoreEl.textContent = score;
    linesEl.textContent = lines;
    levelEl.textContent = level;
}

function start() {
    if (running) return;
    running = true; paused = false;
    spawn();
    lastTime = performance.now();
    requestAnimationFrame(update);
}

function togglePause() {
    if (!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Reanudar' : 'Pausa';
    if (!paused) {
        lastTime = performance.now();
    }
}

/* Mobile controls: only attach if touch device detected (also CSS hides on non-coarse) */
(function setupMobileControls(){
    const mc = document.getElementById('mobileControls');
    const isTouch = ('ontouchstart' in window) || navigator.maxTouchPoints > 0 || window.matchMedia('(pointer:coarse)').matches;
    if (!isTouch) {
        if (mc) mc.style.display = 'none';
        return;
    }
    if (mc) mc.setAttribute('aria-hidden','false');
    // action handlers
    const actionMap = {
        left: () => { if (!running) return; move(-1); draw(); },
        right: () => { if (!running) return; move(1); draw(); },
        rotate: () => { if (!running) return; rotate(current,1); draw(); },
        down: () => { if (!running) return; current.y++; if (collide(grid,current)) { current.y--; lockPiece(); } draw(); },
        drop: () => { if (!running) return; hardDrop(); draw(); }
    };
    let repeatInterval = null;
    let activeAction = null;

    function startRepeat(actionKey) {
        actionMap[actionKey](); // immediate
        activeAction = actionKey;
        // only repeat for left/right/down when holding
        if (actionKey === 'left' || actionKey === 'right' || actionKey === 'down') {
            repeatInterval = setInterval(() => {
                actionMap[actionKey]();
            }, 120);
        }
    }
    function stopRepeat(){
        if (repeatInterval) { clearInterval(repeatInterval); repeatInterval = null; activeAction = null; }
    }

    mc.querySelectorAll('.mc-btn').forEach(btn => {
        const action = btn.getAttribute('data-action');
        // pointer events for better cross-device behavior
        btn.addEventListener('pointerdown', (ev) => {
            ev.preventDefault();
            startRepeat(action);
        });
        btn.addEventListener('pointerup', (ev) => { ev.preventDefault(); stopRepeat(); });
        btn.addEventListener('pointercancel', stopRepeat);
        btn.addEventListener('pointerleave', stopRepeat);
        // also allow quick taps
        btn.addEventListener('click', (ev) => { ev.preventDefault(); if (!activeAction) actionMap[action](); });
    });
})();

/* Init */
reset();
draw();
drawNext();
</script>
</body>
</html>
